# -*- coding: utf-8 -*-
"""Sylviapou_lab8

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pzAJvGKCJOLYnNuy5YDZzqQorNWNEIlf
"""

# Question 1
import polars as pl
df = pl.read_csv("https://raw.githubusercontent.com/pycaret/pycaret/master/datasets/diamond.csv")
rows, cols = df.shape
print(f"- Rows (diamonds): {rows}")
print(f"- Columns (fields): {cols}\n")

# Question 2
print(f"- Columns: {df.columns}\n")

# Question 3
print("Each row represents: ONE DIAMOND (diamond-level grain)\n")

# Question 4
total_carats = df.select(pl.col("Carat Weight").sum().alias("total_carats")).item()
print(f"- Total carats: {total_carats:,.4f}\n")

# Question 5
num_cuts = df.select(pl.col("Cut").n_unique().alias("num_distinct_cuts")).item()
cut_categories = df.select(pl.col("Cut").unique().sort()).to_series().to_list()
print(f"- Number of distinct cuts: {num_cuts}")
print(f"- Cut categories: {cut_categories}\n")

# Question 6
extremes = df.select(
    pl.col("Price").max().alias("max_price"),
    pl.col("Price").min().alias("min_price")
).to_dicts()[0]
max_price, min_price = extremes["max_price"], extremes["min_price"]

print(f"- Highest price: ${max_price:,.2f}")
print(df.filter(pl.col("Price") == max_price)
        .select(["Carat Weight","Cut","Color","Clarity","Polish","Symmetry","Report","Price"]))
print()
print(f"- Lowest price: ${min_price:,.2f}")
print(df.filter(pl.col("Price") == min_price)
        .select(["Carat Weight","Cut","Color","Clarity","Polish","Symmetry","Report","Price"]))
print()

# Question 7
price_by_color = (
    df.group_by("Color")
      .agg([
          pl.col("Price").median().alias("median_price"),
          pl.col("Price").mean().alias("mean_price"),
          pl.len().alias("count")
      ])
      .sort("Color")
)
print(price_by_color)
print("\nReflection after Q7:")
print("New grain = ONE ROW PER COLOR GRADE\n")

# Question 8
clarity_breakdown = (
    df.group_by("Clarity")
      .agg([
          pl.len().alias("num_diamonds"),
          pl.col("Price").median().alias("median_price"),
          pl.col("Carat Weight").sum().alias("total_carats")
      ])
      .sort("Clarity")
)
print(clarity_breakdown, "\n")

# Question 9
cut_color_pricing = (
    df.group_by(["Cut","Color"])
      .agg([
          pl.col("Price").median().alias("median_price"),
          pl.len().alias("count")
      ])
      .sort(["Cut","Color"])
)
# Show a readable sample and total rows
print(cut_color_pricing.head(20))
print(f"... total rows: {cut_color_pricing.height}\n")

print("Reflection after Q9:")
print("New grain = ONE ROW PER (CUT, COLOR) COMBINATION\n")

# Question 10
value_by_segment = (
    df.group_by(["Color","Cut"])
      .agg([
          pl.col("Price").sum().alias("total_value"),
          pl.len().alias("num_diamonds"),
          pl.col("Price").median().alias("median_price"),
          pl.col("Carat Weight").sum().alias("total_carats")
      ])
      .sort("total_value", descending=True)
      .head(5)
)
print(value_by_segment, "\n")

# =========================
# Debrief
# =========================
print("DEBRIEF")
print("- Translate business terms → code ops (total→sum, typical→median/mean, by/for each→group_by).")
print("- Always confirm grain before aggregations.")
print("- Grouping changes grain: diamond-level → color-level → (cut,color)-level, etc.")